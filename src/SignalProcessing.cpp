#include<limits>
#include<mkl.h>
#include<tbb/tbb.h>
#include"SignalProcessing.hpp"
#include"ChannelRemapping.hpp"
#include"Common.hpp"
#include<iostream>
// Assert that these are indeed the same type at compile type due to the unsafe reinterpret_cast 's used in these functions
// Both of these types should be a struct containing two floats
// struct {
//      float real;
//      float imag;
// }
static_assert(std::is_same<decltype(MKL_Complex8::real), decltype(std::complex<float>().real())>::value, "MKL_Complex8 doesn't equal std::complex<float>");
static_assert(std::is_same<decltype(MKL_Complex8::imag), decltype(std::complex<float>().imag())>::value, "MKL_Complex8 doesn't equal std::complex<float>");
static_assert(sizeof(MKL_Complex8) == sizeof(std::complex<float>), "MKL_Complex8 doesn't equal std::complex<float>");
static_assert(alignof(MKL_Complex8) == alignof(std::complex<float>), "MKL_Complex8 doesn't have the same alignt as std::complex<float>");

// Remaps the channels based on the mapping given to it, once the channels are remapped the data may be
// conjugated based on the data in ChannelRemapping.
// This mapping is to be generated by computeChannelRemapping() in ChannelRemapping.hpp
// The signalDataOut will have the same amount of samples as signalData but with the same or different number of channels
void remapChannels(std::vector<std::vector<std::complex<float>>> const& signalDataIn,
                   std::map<unsigned, unsigned> const& signalDataInMapping,
                   std::vector<std::complex<float>>& signalDataOut,
                   std::map<unsigned, ChannelRemapping::RemappedChannel> const& channelRemapping,
                   unsigned const outNumChannels);

static const unsigned PFB_COE_CHANNELS = filterSize;

// Performs an inverse polyphase filter bank (PFB) on the signal data, the mapping is required
// for this function so the convolution only goes over the appropriate channels. This mapping
// is provided by computeChannelRemapping() in ChannelRempping.hpp
void performPFB(std::vector<std::complex<float>>& signalData,
                       std::vector<std::complex<float>> const& coefficantPFB,
                       std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                       unsigned const numOfBlocks,
                       unsigned const numOfChannels);

// Performs an inverse discrete fourier transorm on the signal data, changing the frequency
void performDFT(std::vector<std::complex<float>>& signalData,
                std::vector<float>& outData,
                unsigned const samplingFreq,
                unsigned const numOfBlocks,
                unsigned const numOfChannels,
                unsigned const originalSamplingFreq);

// Converts the downsampled time domain array into a 16bit signed int with clamping
void doPostProcessing(std::vector<float> const& signalData,
                      std::vector<std::int16_t>& signalDataOut);

// Simple function that checks the status of a MKL_LONG and outputs it to console
static inline void handleMKLError(MKL_LONG const status) {
    if ( status && !DftiErrorClass(status, DFTI_NO_ERROR) ) {
        throw SignalProcessingMKLError(DftiErrorMessage(status));
      }
}


// Don't ask why there isn't a function in MKL that does this, I could not find one.
// These messages are taken from the wiki page from where they're listed
// https://software.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/statistical-functions/convolution-and-correlation/convolution-and-correlation-task-status-and-error-reporting.html
static inline std::string getVSLError(int const status) {
    switch(status) {
        case VSL_CC_ERROR_NOT_IMPLEMENTED :	return "Requested functionality is not implemented.";
        case VSL_CC_ERROR_ALLOCATION_FAILURE : return "Memory allocation failure.";
        case VSL_CC_ERROR_BAD_DESCRIPTOR : return "Task descriptor is corrupted.";
        case VSL_CC_ERROR_SERVICE_FAILURE : return "A service function has failed.";
        case VSL_CC_ERROR_EDIT_FAILURE: return "Failure while editing the task.";
        case VSL_CC_ERROR_EDIT_PROHIBITED : return "You cannot edit this parameter.";
        case VSL_CC_ERROR_COMMIT_FAILURE : return "Task commitment has failed.";
        case VSL_CC_ERROR_COPY_FAILURE : return "Failure while copying the task.";
        case VSL_CC_ERROR_DELETE_FAILURE : return "Failure while deleting the task.";
        case VSL_CC_ERROR_BAD_ARGUMENT : return "Bad argument or task parameter.";
        case VSL_CC_ERROR_JOB : return "Bad parameter: job";
        case VSL_CC_ERROR_KIND : return "Bad parameter: kind";
        case VSL_CC_ERROR_MODE : return "Bad parameter: mode";
        case VSL_CC_ERROR_METHOD : return "Bad parameter: method";
        case VSL_CC_ERROR_TYPE : return "Bad parameter: type";
        case VSL_CC_ERROR_EXTERNAL_PRECISION : return "Bad parameter: external_precision";
        case VSL_CC_ERROR_INTERNAL_PRECISION : return "Bad parameter: internal_precision";
        case VSL_CC_ERROR_PRECISION : return "Incompatible external/internal precisions.";
        case VSL_CC_ERROR_DIMS : return "Bad parameter: dims";
        case VSL_CC_ERROR_XSHAPE : return "Bad parameter: xshape";
        case VSL_CC_ERROR_YSHAPE : return "Bad parameter: yshape\ncase Callback function for an abstract BRNG returns an invalid number of updated entries in a buffer, that is, < 0 or >nmax";
        case VSL_CC_ERROR_ZSHAPE : return "Bad parameter: zshape";
        case VSL_CC_ERROR_XSTRIDE : return "Bad parameter: xstride";
        case VSL_CC_ERROR_YSTRIDE : return "Bad parameter: ystride";
        case VSL_CC_ERROR_ZSTRIDE : return "Bad parameter: zstride";
        case VSL_CC_ERROR_X : return "Bad parameter: x";
        case VSL_CC_ERROR_Y : return "Bad parameter: y";
        case VSL_CC_ERROR_Z : return "Bad parameter: z";
        case VSL_CC_ERROR_START : return "Bad parameter: start";
        case VSL_CC_ERROR_DECIMATION : return "Bad parameter: decimation";
        case VSL_CC_ERROR_OTHER : return "Another error. ( Couldn't specify error )";
    }
    return "Couldn't find error";
}
static inline void handleVSLError(int const status) {
    if ( status != VSL_STATUS_OK ) {

        throw SignalProcessingMKLError("Convolution error, error code: " + std::to_string(status) + +", " + getVSLError(status));
    }
}

void processSignal(std::vector<std::vector<std::complex<float>>> const& signalDataIn,
                               std::map<unsigned, unsigned> const& signalDataInMapping,
                               std::vector<std::int16_t>& signalDataOut,
                               std::vector<std::complex<float>> const& coefficiantPFB,
                               ChannelRemapping const& remappingData) {
    if ( remappingData.channelMap.empty() ) {
        throw std::invalid_argument("ChannelRemapping cannot be empty ");
    }

    if ( remappingData.channelMap.size() != signalDataInMapping.size() ) {
        throw std::invalid_argument("Different number of remapped channels and input channels");
    }

    if ( signalDataInMapping.size() != signalDataIn.size() ) {
        throw std::invalid_argument("Number of channels present in input signal do not equal number of channels in mapping");
    }

    unsigned const IN_NUM_CHANNELS = signalDataIn.size();
    unsigned const IN_NUM_BLOCKS = signalDataIn[0].size();

    for (auto iterator = signalDataIn.begin()++; iterator != signalDataIn.end(); ++iterator) {
        if (iterator->size() != IN_NUM_BLOCKS) {
            throw std::invalid_argument("Input signal has different number of blocks for each signal");
        }
    }

    if ( IN_NUM_BLOCKS % 2 != 0 && IN_NUM_BLOCKS != 1 ) {
        throw std::invalid_argument("Number of samples in the input data is not a multiple of 2 or size of 1");
    }

    // New number of channels will be half the number of samples due the nyquist sampling theory
    unsigned const OUT_NUM_CHANNELS = (remappingData.newSamplingFreq / 2) + 1;

    if ( IN_NUM_CHANNELS < OUT_NUM_CHANNELS ) {
        throw std::invalid_argument("New sampling frequency is greater than orginal");
    }

    if ( coefficiantPFB.size() % PFB_COE_CHANNELS != 0 ) {
        throw std::invalid_argument("PFB coefficant data is not a multiple of number of PFB channels "
                + std::to_string(PFB_COE_CHANNELS));
    }

    if ( (coefficiantPFB.size() / PFB_COE_CHANNELS) > signalDataIn[0].size() ) {
        throw std::invalid_argument("The PFB Array must contain the same number or less blocks as the signal data");
    }

    std::vector<float> timeDomain{};
    std::vector<std::complex<float>> remappedData{};
    {
        remapChannels(signalDataIn, signalDataInMapping, remappedData, remappingData.channelMap, OUT_NUM_CHANNELS);
        performPFB(remappedData, coefficiantPFB, remappingData.channelMap, IN_NUM_BLOCKS, OUT_NUM_CHANNELS);
    }
    performDFT(remappedData, timeDomain, remappingData.newSamplingFreq, IN_NUM_BLOCKS, OUT_NUM_CHANNELS, IN_NUM_CHANNELS * 2);
    doPostProcessing(timeDomain, signalDataOut);
}

void remapChannels(std::vector<std::vector<std::complex<float>>> const& signalDataIn,
                   std::map<unsigned, unsigned> const& signalDataInMapping,
                   std::vector<std::complex<float>>& signalDataOut,
                   std::map<unsigned, ChannelRemapping::RemappedChannel> const& channelRemapping,
                   unsigned const outNumChannels) {

    unsigned const NUM_OF_BLOCKS = signalDataIn[0].size();
    // Tell the vector it's size and fill with zeros
    signalDataOut.resize(outNumChannels * NUM_OF_BLOCKS);

    // Work over each element of the mapping
    for (auto map : channelRemapping) {
        // Assign better names to iterator variables
        unsigned const oldChannel = map.first;
        unsigned const newChannel = map.second.newChannel;
        bool const flipped = map.second.flipped;

        // Grab the correct channel vector based on the mapping
        std::vector<std::complex<float>> const& channelVector = signalDataIn[signalDataInMapping.find(oldChannel)->second];

        if (flipped) {
            // Do a strided conjugated copy over it
            vcConjI(NUM_OF_BLOCKS,
                    reinterpret_cast<const MKL_Complex8*>(channelVector.data()), 1,
                    reinterpret_cast<MKL_Complex8*>(signalDataOut.data() + newChannel), outNumChannels);
        }
        else {
            // Do a strided copy over it
            cblas_ccopy(NUM_OF_BLOCKS,
                        channelVector.data(), 1,
                        signalDataOut.data() + newChannel, outNumChannels);
        }

        // I would've liked to do this outside of the loop so it only needs to be done once but due
        // to the fact that the mapping is indexed by the original channel this is not possible!
        // Scale by two for these edge cases
        if ( (newChannel == outNumChannels - 1) || // If nyquist frequency
             (newChannel == 0 && oldChannel != 0) // If something was remapped to zero
            ) {
            cblas_csscal(NUM_OF_BLOCKS, 2, signalDataOut.data() + newChannel, outNumChannels);
        }
    }
}

void performPFB(std::vector<std::complex<float>>& signalData,
                       std::vector<std::complex<float>> const& coefficantPFB,
                       std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                       unsigned const numOfBlocks,
                       unsigned const numOfChannels) {
    unsigned const coefficantBlockSize = coefficantPFB.size() / PFB_COE_CHANNELS;

    VSLConvTaskPtr convolutionTask = nullptr;
    handleVSLError(vslcConvNewTask1D(&convolutionTask,
                      VSL_CORR_MODE_AUTO,
                      numOfBlocks,
                      coefficantBlockSize,
                      (numOfBlocks + coefficantBlockSize) - 1));

    // Temporary Location to do the convolution in
    std::vector<std::complex<float>> convolutionResult((numOfBlocks + coefficantBlockSize) - 1, { 0.0f, 0.0f });


    // Only work over the channels that actually have something in them
    for(auto map : mapping) {
        unsigned const oldChannel = map.first;
        unsigned const newChannel = map.second.newChannel;

        // NOTE: Stride over coefficantPFB data is using the original channel data as it didn't get remapped
        handleVSLError(vslcConvExec1D(convolutionTask,
                       reinterpret_cast<const MKL_Complex8*>(signalData.data() + newChannel), numOfChannels,
                       reinterpret_cast<const MKL_Complex8*>(coefficantPFB.data() + oldChannel), PFB_COE_CHANNELS,
                       reinterpret_cast<MKL_Complex8*>(convolutionResult.data()), 1));

        // Copy the middle part of the convolution back to the orginal array
        cblas_ccopy(numOfBlocks,
                    convolutionResult.data() + coefficantBlockSize/2, 1,
                    signalData.data() + newChannel, numOfChannels);
    }
    vslConvDeleteTask(&convolutionTask);
}

void performDFT(std::vector<std::complex<float>>& signalData,
                std::vector<float>& outData,
                unsigned const samplingFreq,
                unsigned const numOfBlocks,
                unsigned const numOfChannels,
                unsigned const originalSamplingFreq) {
    DFTI_DESCRIPTOR_HANDLE hand;
    outData.resize(samplingFreq * numOfBlocks);
    handleMKLError(DftiCreateDescriptor(&hand, DFTI_SINGLE, DFTI_REAL, 1, samplingFreq));
    handleMKLError(DftiSetValue(hand, DFTI_PACKED_FORMAT, DFTI_CCE_FORMAT));
    handleMKLError(DftiSetValue(hand, DFTI_PLACEMENT, DFTI_NOT_INPLACE));
    handleMKLError(DftiSetValue(hand, DFTI_CONJUGATE_EVEN_STORAGE,  DFTI_COMPLEX_COMPLEX));
    handleMKLError(DftiSetValue(hand, DFTI_BACKWARD_SCALE, 1.0f / static_cast<float>(originalSamplingFreq)));
    handleMKLError(DftiSetValue(hand, DFTI_NUMBER_OF_TRANSFORMS, static_cast<MKL_LONG>(numOfBlocks)));
    handleMKLError(DftiSetValue(hand, DFTI_INPUT_DISTANCE, numOfChannels));
    handleMKLError(DftiSetValue(hand, DFTI_OUTPUT_DISTANCE, samplingFreq));
    handleMKLError(DftiCommitDescriptor(hand));
    handleMKLError(DftiComputeBackward(hand, signalData.data(), outData.data()));
    handleMKLError(DftiFreeDescriptor(&hand));
}

constexpr std::int16_t clamp(float n) {
    if (n > std::numeric_limits<std::int16_t>::max()) { return std::numeric_limits<std::int16_t>::max(); }
    if (n < std::numeric_limits<std::int16_t>::min()) { return std::numeric_limits<std::int16_t>::min(); }
    return static_cast<std::int16_t>(n);
}

void doPostProcessing(std::vector<float> const& signalData,
                             std::vector<std::int16_t>& signalDataOut) {
    signalDataOut.resize(signalData.size());

    tbb::parallel_for(size_t{0}, signalData.size(), [&signalData, &signalDataOut](size_t ii) {
        signalDataOut[ii] = clamp(signalData[ii]);
    });
}
