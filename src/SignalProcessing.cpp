#include<algorithm>
#include<iostream>
#include<map>
#include<mkl.h>
#include<tbb/tbb.h>
#include"SignalProcessing.hpp"
#include"ChannelRemapping.hpp"

// Remaps the channels based on the mapping given to it, once the channels are remapped the data may be
// conjugated based on the data in ChannelRemapping.
// This mapping is to be generated by computeChannelRemapping() in ChannelRemapping.hpp
// The signalOut will have the same amount of samples as signalData but with the same or different number of channels
static void remapChannels(std::vector<std::complex<float>> const& signalData,
                          std::vector<std::complex<float>>& signalOut,
                          std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                          unsigned const numberOfSamples,
                          unsigned const newNumChannels);

// Performs an inverse polyphase filter bank (PFB) on the signal data, the mapping is required
// for this function so the convolution only goes over the appropriate channels. This mapping
// is provided by computeChannelRemapping() in ChannelRempping.hpp
static void performPFB(std::vector<std::complex<float>> const& signalData,
                       std::vector<std::complex<float>>& signalOut,
                       std::vector<std::complex<float>> const& coefficantPFB,
                       std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                       unsigned const numberOfSamples,
                       unsigned const numOfChannels);

// Performs an inverse discrete fourier transorm on the signal data, changing the frequency
// data into a time domain signal this is done in place! DO NOT use imaginary conmpenent of the data
// this is done to save a copy.
static void performDFT(std::vector<std::complex<float>>& signalData);

// Converts the downsampled time domain array into a 16bit signed int with clamping
static void doPostProcessing(std::vector<std::complex<float>> const& signalData,
                             std::vector<std::int16_t>& signalOut);

// Simple function that checks the status of a MKL_LONG and outputs it to console
// TODO: throw exception.
static void handleMKLError(MKL_LONG status) {
    if ( status && !DftiErrorClass(status, DFTI_NO_ERROR) ) {
           std::cout << "Error: " << DftiErrorMessage(status) << std::endl;
      }
}

std::vector<std::int16_t> processSignal(std::vector<std::complex<float>> const& signalData,
                               std::vector<std::complex<float>> const& coefficiantPFB,
                               ChannelRemapping const& remappingData) {
    std::cout << "ProcessSignal Called" << std::endl;

    unsigned const IN_NUM_SAMPLES = signalData.size() / remappingData.channelMap.size();
    unsigned const OUT_NUM_CHANNELS = remappingData.newSamplingFreq / 2;

    std::vector<std::complex<float>> remappedData = std::vector<std::complex<float>>();
    std::vector<std::complex<float>> convolvedData = std::vector<std::complex<float>>();
    std::vector<std::int16_t> outData = std::vector<std::int16_t>();



    // remapChannels(signalData, remappedData, remappingData);
    // performPFB(signalData, convolvedData, coefficiantPFB, remappingData.channelMap);
    // performDFT(convolvedData);
    // doPostProcessing(signalData, outData);

    return outData;
}

static void remapChannels(std::vector<std::complex<float>> const& signalData,
                          std::vector<std::complex<float>>& signalOut,
                          std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                          unsigned const numberOfSamples,
                          unsigned const newNumOfChannels) {
    // Tell the vector it's size
    signalOut.reserve(newNumOfChannels * numberOfSamples);

    // Work over each element of the mapping
    for (auto map : mapping) {
        // Assign better names to iterator variables
        unsigned oldChannel = map.first;
        unsigned newChannel = map.second.newChannel;
        bool flipped = map.second.flipped;

        if (flipped) {
            // Do a strided conjugated copy over it
            vcConjI(numberOfSamples,
                    (MKL_Complex8*)&signalData.data()[oldChannel], mapping.size(),
                    (MKL_Complex8*)&signalOut.data()[newChannel], newNumOfChannels);
        }
        else {
            // Do a strided copy over it
            cblas_ccopy(numberOfSamples,
                        &signalData.data()[oldChannel], mapping.size(),
                        &signalOut.data()[newChannel], newNumOfChannels);
        }
    }

}

static void performPFB(std::vector<std::complex<float>> const& signalData,
                       std::vector<std::complex<float>>& outSignal,
                       std::vector<std::complex<float>> const& coefficantPFB,
                       std::map<unsigned, ChannelRemapping::RemappedChannel> const& mapping,
                       unsigned const numberOfSamples,
                       unsigned const numOfChannels) {
    VSLConvTaskPtr convolutionTask = nullptr;

    // TODO: handle the error cases for this function
    vslcConvNewTask1D(&convolutionTask,
                      VSL_CORR_MODE_AUTO,
                      numberOfSamples,
                      coefficantPFB.size() / numOfChannels,
                      numberOfSamples);

    // Only work over the channels that actually have something in them
    for(auto map : mapping) {
        unsigned const oldChannel = map.first;
        unsigned const newChannel = map.second.newChannel;
        // TODO: handle error cases for this function call
        // NOTE: Stride over coefficantPFB data is using the original channel data as it didn't get remapped
        vslcConvExec1D(convolutionTask,
                       (MKL_Complex8*)&signalData.data()[newChannel], numOfChannels,
                       (MKL_Complex8*)&outSignal.data()[newChannel], numOfChannels,
                       (MKL_Complex8*)&coefficantPFB.data()[oldChannel], mapping.size());
    }
}

static void performDFT(std::vector<std::complex<float>>& signalData) {
    DFTI_DESCRIPTOR_HANDLE hand;

    handleMKLError(DftiCreateDescriptor(&hand, DFTI_SINGLE, DFTI_COMPLEX, 1, signalData.size()));
    handleMKLError(DftiCommitDescriptor(hand));
    handleMKLError(DftiComputeBackward(hand, signalData.data()));
    handleMKLError(DftiFreeDescriptor(&hand));
}

static inline std::int16_t clamp(float n) {
    if (n > INT16_MAX) return INT16_MAX;
    if (n < INT16_MIN) return INT16_MIN;
    return static_cast<std::int16_t>(n);
}

static void doPostProcessing(std::vector<std::complex<float>> const& signalData,
                             std::vector<std::int16_t>& signalOut) {
    signalOut.reserve(signalData.size());
    // This is the only way to get the parallel for to work for some reason
    std::int16_t* out = signalOut.data();
    tbb::parallel_for(size_t(0), signalData.size(), [=](size_t ii) {
            out[ii] = clamp(signalData[ii].real());
     });
}
